{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/zustands는 어떻게 root provider 없이 상태관리를 할 수 있을까(1)/","result":{"data":{"site":{"siteMetadata":{"title":"wkd2ev"}},"markdownRemark":{"id":"fcc608fb-7c94-5a4a-bed1-edf260ca39fa","excerpt":"redux, recoil과는 다르게 zustand는 어떻게 root provider 없이 상태관리를 하는지\n궁금했다. 아래는 리덕스 공식문서 튜토리얼에서 가져온 예제이다.\nhttps://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react…","html":"<p>redux, recoil과는 다르게 zustand는 어떻게 root provider 없이 상태관리를 하는지\n궁금했다.</p>\n<p>아래는 리덕스 공식문서 튜토리얼에서 가져온 예제이다.\n<a href=\"https://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react/#passing-the-store-with-provider\">https://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react/#passing-the-store-with-provider</a></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport { Provider } from &#39;react-redux&#39;\n\nimport App from &#39;./App&#39;\nimport store from &#39;./store&#39;\n\nReactDOM.render(\n  // Render a `&lt;Provider&gt;` around the entire `&lt;App&gt;`,\n  // and pass the Redux store to as a prop\n  &lt;React.StrictMode&gt;\n    &lt;Provider store={store}&gt; &lt;-------------------------- provider\n      &lt;App /&gt;\n    &lt;/Provider&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById(&#39;root&#39;)\n)</code>\n        </deckgo-highlight-code>\n<p>아래는 recoil 예제이다.\n<a href=\"https://recoiljs.org/ko/docs/introduction/getting-started\">https://recoiljs.org/ko/docs/introduction/getting-started</a></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\nimport {\n  RecoilRoot,\n  atom,\n  selector,\n  useRecoilState,\n  useRecoilValue,\n} from &#39;recoil&#39;;\n\nfunction App() {\n  return (\n    &lt;RecoilRoot&gt;      &lt;-------------------------- provider\n      &lt;CharacterCounter /&gt;\n    &lt;/RecoilRoot&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇듯 전역상태 라이브러리는 앱의 최상단에 위치하여 상태를 관리한다.\n<a href=\"https://www.slash.page/ko/libraries/react/use-overlay/src/useOverlay.i18n\">https://www.slash.page/ko/libraries/react/use-overlay/src/useOverlay.i18n</a>\ntoss에서 만든 modal을 선언적으로 관리하기 위한 훅도 최상단에서 모달을 관리한다. 아래는 useOverlay의 root provider 코드이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">/** @tossdocs-ignore */\nimport React, { createContext, PropsWithChildren, ReactNode, useCallback, useMemo, useState } from &#39;react&#39;;\n\nexport const OverlayContext = createContext&lt;{\n  mount(id: string, element: ReactNode): void;\n  unmount(id: string): void;\n} | null&gt;(null);\nif (process.env.NODE_ENV !== &#39;production&#39;) {\n  OverlayContext.displayName = &#39;OverlayContext&#39;;\n}\n\nexport function OverlayProvider({ children }: PropsWithChildren) {\n  const [overlayById, setOverlayById] = useState&lt;Map&lt;string, ReactNode&gt;&gt;(new Map()); // &lt;------- 여기서 모달 관리\n\n  const mount = useCallback((id: string, element: ReactNode) =&gt; {\n    setOverlayById(overlayById =&gt; {\n      const cloned = new Map(overlayById);\n      cloned.set(id, element);\n      return cloned;\n    });\n  }, []);\n\n  const unmount = useCallback((id: string) =&gt; {\n    setOverlayById(overlayById =&gt; {\n      const cloned = new Map(overlayById);\n      cloned.delete(id);\n      return cloned;\n    });\n  }, []);\n\n  const context = useMemo(() =&gt; ({ mount, unmount }), [mount, unmount]);\n\n  return (\n    &lt;OverlayContext.Provider value={context}&gt;\n      {children}\n      {[...overlayById.entries()].map(([id, element]) =&gt; (\n        &lt;React.Fragment key={id}&gt;{element}&lt;/React.Fragment&gt;\n      ))}\n    &lt;/OverlayContext.Provider&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇듯 전역으로 상태를 관리 하기 위해서는 최상단 루트 컴포넌트에 상태를 선언하고 이를 children으로 받아서 관리해주고 있다.\n그러나 zustand는 root provider 없이 바로 컴포넌트에서 바로 사용할 수 있다. 이는 어떻게 가능한 것인가.</p>\n<h2>zustand 코드 파헤쳐 보기</h2>\n<p>핵심 로직은 생각보다 간단했다. 코드라인도 길지 않았다. 먼저 사용법은 다음과 같다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { create } from &#39;zustand&#39;\n\nconst useStore = create((set) =&gt; ({\n  count: 1,\n  inc: () =&gt; set((state) =&gt; ({ count: state.count + 1 })),\n}))</code>\n        </deckgo-highlight-code>\n<p>아래는 zustand의 타입과 불필요한 코드를 제거한 가져온 핵심 코드들이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import useSyncExternalStoreExports from &#39;use-sync-external-store/shim/with-selector&#39;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports\n\nconst createStore = (createState) =&gt; {\n  let state\n  const listeners = new Set()\n\n  const setState = (partial, replace) =&gt; {\n    // TODO: Remove type assertion once https://github.com/microsoft/TypeScript/issues/37663 is resolved\n    // https://github.com/microsoft/TypeScript/issues/37663#issuecomment-759728342\n    const nextState =\n      typeof partial === &#39;function&#39;\n        ? partial(state)\n        : partial\n    if (!Object.is(nextState, state)) {\n      const previousState = state\n      state =\n        replace ?? (typeof nextState !== &#39;object&#39; || nextState === null)\n          ? nextState\n          : Object.assign({}, state, nextState)\n      listeners.forEach((listener) =&gt; listener(state, previousState))\n    }\n  }\n\n  const getState = () =&gt; state\n\n  const getInitialState = () =&gt; initialState\n\n  const subscribe = (listener) =&gt; {\n    listeners.add(listener)\n    // Unsubscribe\n    return () =&gt; listeners.delete(listener)\n  }\n\n  const destroy = () =&gt; {\n    listeners.clear()\n  }\n\n  const api = { setState, getState, getInitialState, subscribe, destroy }\n  const initialState = (state = createState(setState, getState, api))\n  return api;\n}\n\nexport function useStore(\n  api,\n  selector,\n  equalityFn?,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn,\n  )\n  return slice\n}\n\nconst createImpl = (createState) =&gt; {\n  const api =\n    typeof createState === &#39;function&#39; ? createStore(createState) : createState\n\n  const useBoundStore = (selector, equalityFn) =&gt;\n    useStore(api, selector, equalityFn)\n\n  Object.assign(useBoundStore, api)\n\n  return useBoundStore\n}\n\nexport const create = ((createState) =&gt; createState ? createImpl(createState) : createImpl);</code>\n        </deckgo-highlight-code>\n<p>정말이지 이게 끝이다. 물론 기타 타입코드와 여러가지가 다른 코드가 존재하지만 핵심은 이것이다.\n먼저 createStore의 코드를 살펴보자.</p>\n<p>zustand는 <strong>Observer Pattern</strong>을 사용한다. 프론트엔드에서 빠질 수 없는 패턴이랴\n여기서 listener 함수를 받는데 아래 <em>listener</em> 함수가 어디서 왔는지 서술하겠다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const setState = (partial, replace) =&gt; {\n  const nextState = 생략;\n  listeners.forEach((listener) =&gt; listener(state, previousState))\n}\n\nconst getState = () =&gt; state\n\nconst getInitialState = () =&gt; initialState\n\nconst subscribe = (listener) =&gt; {\n  listeners.add(listener)\n  // Unsubscribe\n  return () =&gt; listeners.delete(listener)\n  }</code>\n        </deckgo-highlight-code>\n<p>처음 컴포넌트가 마운트 되었을 때 subscribe 함수가 호출된다. 그 이후에 상태를 업데이트 할 때 해당 파라미터가 콜백인지 아닌지\n확인하고 다음 값을 갱신한 후에 리스너들을 순회하여 리스너 함수를 호출한다.\n이렇게 api 객체를 만들어 <strong>useSyncExternalStoreWithSelector</strong> 의 파라미터로 넘긴다.</p>\n<h2>useSyncExternalStore</h2>\n<p>react 18이 릴리즈 되면서 나온 훅이다. 해당 게시글에서 <strong>useSyncExternalStore</strong> 를 자세히 설명할 것은 아니고\n해당 훅은 외부 스토어의 tearing 현상을 막기 위해 리액트 내부와 싱크를 맞추는 훅이다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=KEDUqA9JeIo\">https://www.youtube.com/watch?v=KEDUqA9JeIo</a>\n위 영상에서 useSyncExternalStore를 사용하여 커스텀 상태관리를 만들고 있다.</p>\n<p><strong>useSyncExternalStore</strong> 은 첫번째 인자로 subscribe 함수를 받고 있다. 두번쨰 파라미터로는 해당 상태의 스냅샷을 받는 함수를 받고있다.\n여기서 두번쨰 파라미터로 상태 객체를 전달하는게 아닌 함수 형태로 () => state 전달해야 하는데 이는 클로져의 특성을 활용하여\n매번 변경되는 state를 반환하기 위함이다. 여기서 중요한 것은 저 listener 함수이다.\nlistener 함수는 대체 어디서 넣어주는 것일까?</p>\n<p>subscribe 함수에 console.log(listener.name) 를 출력해보면 다음과 같은 함수 이름이 나타난다.</p>\n<blockquote>\n<p>handleStoreChange</p>\n</blockquote>\n<h3>handleStoreChange</h3>\n<p><a href=\"https://github.com/facebook/react/blob/f74c5ccf9469d3389ce3a1ee3b54988049e235f7/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L110\">https://github.com/facebook/react/blob/f74c5ccf9469d3389ce3a1ee3b54988049e235f7/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L110</a></p>\n<p><strong>handleStoreChange</strong> 해당 함수는 여기서 주입하고 있었다.\nzustand는 react에서 제공하는 useState, useReducer 없이도 <strong>useSyncExternalStore</strong> 훅을 통하여\nsubscribe 함수 의존성을 받아서 리액트에서 상태를 관리해주고 있었디.</p>\n<p>아래는 <strong>useSyncExternalStoreShimClient</strong> 의 일부를 가져온 것이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const [{inst}, forceUpdate] = useState({inst: {value, getSnapshot}});\n\nuseEffect(() =&gt; {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n    const handleStoreChange = () =&gt; {\n      // TODO: Because there is no cross-renderer API for batching updates, it&#39;s\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn&#39;t\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst}); &lt;----------------------------------- 상태 업데이트 코드\n      }\n    };\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n  }, [subscribe]);</code>\n        </deckgo-highlight-code>\n<h2>직접 구현해보기</h2>\n<p>이제 zustand를 참고하여 직접 커스텀 상태관리를 구현해보자. <strong>useSyncExternalStore</strong> 를 사용한다면 아주 간단한 상태관리를 구현할 수 있을 것이다.\n상태 관리는 리액트에 위임하고 개발자는 그저 subscribe 함수와 상태 업데이트 시 리스너들을 호출해주면 될 것이다.</p>\n<p>최종적으로 createStore 함수로 초기 상태값을 받고 반환받은 값을 컴포넌트의 훅형태로 쓸 수 있도록 할 것이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { useCallback, useSyncExternalStore } from &#39;react&#39;;\n\nconst createStore = (initialState) =&gt; {\n  let state = initialState;\n\n  const getState = () =&gt; state;\n\n  const listeners = new Set();\n\n  const setState = (fn) =&gt; {\n    state = fn(state);\n    listeners.forEach((listener) =&gt; listener());\n  };\n\n  const subscribe = (listener) =&gt; {\n    listeners.add(listener);\n    return () =&gt; listeners.delete(listener);\n  };\n\n  return { getState, setState, subscribe };\n};\n\n\nconst useStore = (store, selector) =&gt; {\n  const slice = useSyncExternalStore(\n    store.subscribe,\n    useCallback(() =&gt; selector(store.getState()), [store, selector])\n  );\n\n  return [slice, store.setState];\n};</code>\n        </deckgo-highlight-code>\n<p>정말이지 간단하게 만들었다. zustand 로직보다는 간단하지만 결국 핵심 패턴은 옵저버 패턴을 이용한 <strong>useSyncExternalStore</strong> 훅 사용에 있다.\n여기서 <strong>useSyncExternalStore</strong> 두번쨰 인자로 상태의 스냅샷을 사용하는 쪽에서 selector로 select할 수 있도록 했다.\nstore와 selector를 의존성으로 받아 불필요한 리렌더링이 발생하지 않도록 <strong>useCallback</strong> 으로 감싸주었다.</p>\n<p>잘 되는지 테스트를 작성해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">test(&#39;형제간 상태 공유&#39;, () =&gt; {\n  const store = createStore({ count: 0 });\n\n  function Brother1() {\n    const [count, setState] = useStore(store, (state) =&gt; state.count);\n\n    return (\n      &lt;React.Fragment&gt;\n        &lt;button\n          onClick={() =&gt; {\n            setState((prev) =&gt; ({ count: prev.count + 1 }));\n          }}\n        &gt;\n          inc\n        &lt;/button&gt;\n        &lt;button\n          onClick={() =&gt; {\n            setState((prev) =&gt; ({ count: prev.count - 1 }));\n          }}\n        &gt;\n          dec\n        &lt;/button&gt;\n        &lt;h1 data-testid=&quot;brother1&quot;&gt;value: {count}&lt;/h1&gt;\n      &lt;/React.Fragment&gt;\n    );\n  }\n\n  function Brother2() {\n    const [count] = useStore(store, (state) =&gt; state.count);\n\n    return (\n      &lt;React.Fragment&gt;\n        &lt;h1 data-testid=&quot;brother2&quot;&gt;value: {count}&lt;/h1&gt;\n      &lt;/React.Fragment&gt;\n    );\n  }\n\n  function Parent() {\n    return (\n      &lt;React.Fragment&gt;\n        &lt;Brother1 /&gt;\n        &lt;Brother2 /&gt;\n      &lt;/React.Fragment&gt;\n    );\n  }\n\n  const { getByText, getByTestId } = render(&lt;Parent /&gt;);\n  fireEvent.click(getByText(&#39;inc&#39;));\n  expect(getByTestId(&#39;brother1&#39;).textContent).toBe(&#39;value: 1&#39;);\n  expect(getByTestId(&#39;brother2&#39;).textContent).toBe(&#39;value: 1&#39;);\n\n  fireEvent.click(getByText(&#39;dec&#39;));\n  expect(getByTestId(&#39;brother1&#39;).textContent).toBe(&#39;value: 0&#39;);\n  expect(getByTestId(&#39;brother2&#39;).textContent).toBe(&#39;value: 0&#39;);\n});</code>\n        </deckgo-highlight-code>\n<p>잘 통과된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3383e58e5e3d805a548253deba24ec49/874d1/test.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.354430379746837%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAqElEQVR42m2QXQ6CMBCEexwKFVCEApWi/BkFJfHV+59j3CXVEPXhy842m9nZinF+wtgRdXOHPd1QVheoyCBOauhyQJp3yJiiX0id9gINz89+EMZecWxnNOcHGfSIthV8GvZVDhWWCAi14t3/M1sMNW1L8gbZNEF3I5kVkGTIrFPIr0S8kJGMC8CIVLfYEzWl5FM4YUhwjXcWm/jw0aHTS6Wev4Xfo9X8C3O6gY6GW619AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test\"\n        title=\"\"\n        src=\"/static/3383e58e5e3d805a548253deba24ec49/f058b/test.png\"\n        srcset=\"/static/3383e58e5e3d805a548253deba24ec49/c26ae/test.png 158w,\n/static/3383e58e5e3d805a548253deba24ec49/6bdcf/test.png 315w,\n/static/3383e58e5e3d805a548253deba24ec49/f058b/test.png 630w,\n/static/3383e58e5e3d805a548253deba24ec49/40601/test.png 945w,\n/static/3383e58e5e3d805a548253deba24ec49/78612/test.png 1260w,\n/static/3383e58e5e3d805a548253deba24ec49/874d1/test.png 1310w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>다음 포스트는 <strong>useSyncExternalStore</strong> 훅 이전 zustand3 버전에서는 어떻게 상태 관리를 하는지 알아보겠다.</p>","frontmatter":{"title":"zustands는 어떻게 root provider 없이 상태관리를 할 수 있을까(1)","date":"2024-05-19","description":"useSyncExternalStore"}},"previous":{"fields":{"slug":"/타입 세이프하게 api를 호출해보자/"},"frontmatter":{"title":"타입 세이프하게 api를 호출해보기"}},"next":{"fields":{"slug":"/qa 과정에서 깃헙페이지에 멀티 페이지 배포 워크플로우 작성해보기/"},"frontmatter":{"title":"qa 과정에서 깃헙페이지에 멀티 페이지 배포 워크 플로우 작성해보기"}}},"pageContext":{"id":"fcc608fb-7c94-5a4a-bed1-edf260ca39fa","previousPostId":"f60ee1fa-8ff9-5794-b402-e21d567fc740","nextPostId":"ae22ba41-45bb-5046-b973-f0cd5baaf80c"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}