{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/type challange <Easy>/","result":{"data":{"site":{"siteMetadata":{"title":"wkd2ev"}},"markdownRemark":{"id":"63ef87be-f787-5e4b-b690-a99e9ad1c3d1","excerpt":"타입 챌린지 easy를 풀어봅시다...\nhttps://github.com/type-challenges/type-challenges?tab=readme-ov-file Pick 타입스크립트에서 기본적으로 제공해주는 유틸리티 타입인 Pick…","html":"<p>타입 챌린지 easy를 풀어봅시다...\n<a href=\"https://github.com/type-challenges/type-challenges?tab=readme-ov-file\">https://github.com/type-challenges/type-challenges?tab=readme-ov-file</a></p>\n<h3>Pick</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ninterface Todo {\n  title: string\n  description: string\n  completed: boolean\n}\n \ntype TodoPreview = MyPick&lt;Todo, &#39;title&#39; | &#39;completed&#39;&gt;\n \nconst todo: TodoPreview = {\n    title: &#39;Clean room&#39;,\n    completed: false,\n}\n\n// A\ntype MyPick&lt;T, K extends keyof T&gt; = {\n  [key in K]: T[key];\n}</code>\n        </deckgo-highlight-code>\n<p>타입스크립트에서 기본적으로 제공해주는 유틸리티 타입인 Pick이다.\n제너릭의 두번째 인자로 뽑고싶은 속성만 추출한다.\nK extends keyof T 는 K가 T 제너릭 타입이 가지고 있는 속성들의 서브타입임을 명시해준다.</p>\n<h3>Readonly</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ninterface Todo {\n  title: string\n  description: string\n}\n \nconst todo: MyReadonly&lt;Todo&gt; = {\n  title: &quot;Hey&quot;,\n  description: &quot;foobar&quot;\n}\n \ntodo.title = &quot;Hello&quot; // Error: cannot reassign a readonly property\ntodo.description = &quot;barFoo&quot; // Error: cannot reassign a readonly property\n\n// A\ntype MyReadonly&lt;T&gt; = {\n  readonly [key in keyof T]: T[key];\n}</code>\n        </deckgo-highlight-code>\n<p>모든 속성을 읽기 속성으로 만들어야 한다.</p>\n<h3>FirstofArray</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\ntype arr2 = [3, 2, 1]\n \ntype head1 = First&lt;arr1&gt; // expected to be &#39;a&#39;\ntype head2 = First&lt;arr2&gt; // expected to be 3\ntype head3 = First&lt;[]&gt; // expected to be never\n\n// A\ntype First&lt;T extends any[]&gt; = T extends [] ? never : T[0];</code>\n        </deckgo-highlight-code>\n<p>원소[0] 을 반환하면 될 것 같지만 빈 배열일 경우에도 생각해야 한다.</p>\n<p>조건부 연산을 사용하여 제너릭 T가 빈배열의 서브타입일 경우 never를 반환하고\n아니라면 0번째 인덱스를 반환해준다.</p>\n<h3>Length of Tuple</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type tesla = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;]\ntype spaceX = [&#39;FALCON 9&#39;, &#39;FALCON HEAVY&#39;, &#39;DRAGON&#39;, &#39;STARSHIP&#39;, &#39;HUMAN SPACEFLIGHT&#39;]\n \ntype teslaLength = Length&lt;tesla&gt;  // expected 4\ntype spaceXLength = Length&lt;spaceX&gt; // expected 5\n\ntype Length&lt;T extends any[]&gt; = T[&quot;length&quot;];</code>\n        </deckgo-highlight-code>\n<p>length 프로퍼티를 이용하여 반환하면 된다. 다만 as const로 타입 단언이 선언되었을 경우\n다음과 같이 작성해줘야 한다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">const tesla = [&#39;tesla&#39;, &#39;model 3&#39;, &#39;model X&#39;, &#39;model Y&#39;] as const;\ntype TeslaLen = Length&lt;typeof tesla&gt;; &lt;---- ????\n\ntype Length&lt;T extends readonly any[]&gt; = T[&quot;length&quot;];</code>\n        </deckgo-highlight-code>\n<h3>Exclude</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype Result = MyExclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39;&gt; // &#39;b&#39; | &#39;c&#39;\n\n// A\ntype MyExclude&lt;T, U&gt; = T extends U ? never : T;</code>\n        </deckgo-highlight-code>\n<p>첫 제너릭 속성에는 유니온 타입을 두번쨰 제너릭 인자로 제외하고 싶은 타입을 넣어\n제외시키는 타입이다.</p>\n<p>T가 U의 서브타입이라면 never를 반환</p>\n<p>'a' | 'b' | 'c' 중 'a'는 두번째 제너릭으로 들어온 타입 'a'의 서브타입이므로 never를 반환하고 아님 T를 반환한다.</p>\n<h3>Awaited</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype X = Promise&lt;string&gt;\ntype Y = Promise&lt;{ field: number }&gt;\n\n// A\ntype MyAwaited&lt;T&gt; = T extends Promise&lt;infer R&gt; ? R : never;</code>\n        </deckgo-highlight-code>\n<p>프로미스의 타입을 뽑아내는 문제이다.\ninfer 키워드를 사용하여 타입을 추출할 수 있다.</p>\n<p>하지만 다음과 같이 프로미스가 프로미스를 반환한다면 프로미스가 프로미스를 반환하고\n재귀적으로 프로미스를 반환해줄 경우 재귀적으로 타입을 작성해준다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type Z = MyAwaited&lt;Promise&lt;string | number&gt;&gt;\ntype Z1 = MyAwaited&lt;Promise&lt;Promise&lt;string | boolean&gt;&gt;&gt;\n\ntype MyAwaited&lt;T extends Promise&lt;unknown&gt;&gt; = T extends Promise&lt;infer R&gt; \n  ? R extends Promise&lt;unknown&gt;\t\t// R이 프로미스의의 서브타입이라면\n    ? MyAwaited&lt;R&gt;\t\t\t// 재귀적으로 R을 던짐으로 호출\n    : R\t\t// R이 프로미스의 서브타입이 아니라면 R을 반환\n  : never; // 모든 케이스에 대응하지 않은 경우 never 반환</code>\n        </deckgo-highlight-code>\n<h3>IF</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type A = If&lt;true, &#39;a&#39;, &#39;b&#39;&gt;  // expected to be &#39;a&#39;\ntype B = If&lt;false, &#39;a&#39;, &#39;b&#39;&gt; // expected to be &#39;b&#39;\n\ntype If&lt;C extends boolean, T, F&gt; = C extends true ? T : F;</code>\n        </deckgo-highlight-code>\n<h3>Concat</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype Result1 = MyConcat&lt;[], []&gt;\ntype Result2 = MyConcat&lt;[], [1]&gt;\ntype Result3 = MyConcat&lt;[1, 2], [3, 4]&gt;\ntype Result4 = MyConcat&lt;[&#39;1&#39;, 2, &#39;3&#39;], [false, boolean, &#39;4&#39;]&gt;\n\n// A\ntype MyConcat&lt;T extends any[], U extends any[]&gt; = [...T, ...U];</code>\n        </deckgo-highlight-code>\n<p>스프레드 연산자로 합쳐주면 된다.</p>\n<h3>Equal</h3>\n<p>해당 타입은 문제에 없지만 후에 나올 Include 타입 문제에 쓰이기 때문에 한번 알아본다.\n타입이 동등한지를 비교하는 타입이다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">interface Person {\n  name: string;\n  age: number;\n}\n \ninterface Person2 {\n  name: string;\n  age: number;\n}\n \ninterface OtherType {\n  name:string;\n  money: number;\n}\n \ntype Result1 = Equals&lt;Person, Person&gt;;  // expected true\ntype Result2 = Equals&lt;Person, Person2&gt;;  // expected true\ntype Result3 = Equals&lt;Person2, OtherType&gt;;  // expected false\n\ntype Equals&lt;X, Y&gt; = \n  (&lt;T&gt;() =&gt; T extends X ? &quot;A&quot; : &quot;B&quot;) extends (&lt;T&gt;() =&gt; T extends Y ? &quot;A&quot; : &quot;B&quot;)\n  ? true\n  : false;</code>\n        </deckgo-highlight-code>\n<p>꽤나 신기한 타입이다.\n제너릭 T를 받아 해당 타입이 Equals타입의 두 제너릭 타입의 서브 타입인지를 비교하고 또 서로 비교하는 과정을\n통해 true, false를 반환한다.</p>\n<h3>Include</h3>\n<p>배열 원소에 타입이 포함되어 있는지를 묻는 문제이다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype isPillarMen = Includes&lt;[&#39;Kars&#39;, &#39;Esidisi&#39;, &#39;Wamuu&#39;, &#39;Santana&#39;], &#39;Dio&#39;&gt; // expected to be `false`\n\n// A\ntype Equal&lt;X, Y&gt; =\n  (&lt;T&gt;() =&gt; T extends X ? &quot;A&quot; : &quot;B&quot;) extends (&lt;T&gt;() =&gt; T extends Y ? &quot;A&quot; : &quot;B&quot;)\n  ? true\n  : false;\n \ntype Includes&lt;T extends readonly any[], U&gt; = T extends [infer First, ...infer Rest] // 제너릭 T 타입은 infer로 타입을 추출 처음 원소와 나머지 원소로 분리한다.\n  ? Equal&lt;First, U&gt; extends true\t// Equal 타입으로 첫번째 원소와 U를 비교를 하고 true의 서브타입인지 판별한다.\n    ? true\t\t\t\t// 조건이 맞다면 true를 반환\n    : Includes&lt;Rest, U&gt;\t\t\t// 1에서 판별한 조건이 아니라면 재귀적으로 나머지 배열 원소의 타입들을 넣어주어 재귀적으로 호출한다.\n  : false;\t\t\t\t// 모든 케이스에 대응 안하는 경우 false를 반환</code>\n        </deckgo-highlight-code>\n<h3>Push</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype Result = Push&lt;[1, 2], &#39;3&#39;&gt; // [1, 2, &#39;3&#39;]\n\n// A\ntype Push&lt;T extends any[], U&gt; = [...T, U];\n</code>\n        </deckgo-highlight-code>\n<h3>Unshift</h3>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\ntype Result = Unshift&lt;[1, 2], 0&gt; // [0, 1, 2,]\n\n// A\ntype Unshift&lt;T extends any[], U&gt; = [U, ...T];</code>\n        </deckgo-highlight-code>\n<h3>Parameters</h3>\n<p>함수의 파라미터를 추출하는 문제다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// Q\nconst foo = (arg1: string, arg2: number): void =&gt; {}\n \ntype FunctionParamsType = MyParameters&lt;typeof foo&gt; // [arg1: string, arg2: number]\n\n// A\ntype MyParameters&lt;T extends (...args: any[]) =&gt; any&gt; = \n  T extends (...args: infer R) =&gt; any\n  ? R\n  : never;</code>\n        </deckgo-highlight-code>\n<p>함수의 파라미터 타입을 infer로 추론한다.\n제너릭으로 받은 T타입이 함수 형태가 아니라면 never를 반환한다.</p>","frontmatter":{"title":"type challange <Easy>","date":"2022-11-13","description":"easy"}},"previous":null,"next":{"fields":{"slug":"/타입 세이프하게 api를 호출해보자/"},"frontmatter":{"title":"타입 세이프하게 api를 호출해보기"}}},"pageContext":{"id":"63ef87be-f787-5e4b-b690-a99e9ad1c3d1","previousPostId":null,"nextPostId":"f60ee1fa-8ff9-5794-b402-e21d567fc740"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}