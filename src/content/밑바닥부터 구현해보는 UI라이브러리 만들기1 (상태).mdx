---
title: 밑바닥부터 구현해보는 UI라이브러리 만들기1 (상태)
date: "2026-01-21"
description: "lit, vue, react, proxy"
priority: 9
---
**예제링크**

npm 링크: [https://www.npmjs.com/package/reona](https://www.npmjs.com/package/reona)

프로젝트 링크: [https://github.com/dkpark10/reona](https://github.com/dkpark10/reona)

해당 게시글에 관한 링크: [https://github.com/dkpark10/reona-track/tree/master/track/01-state](https://github.com/dkpark10/reona-track/tree/master/track/01-state)

## 아키텍처 설계

인터페이스는 react와 동일하게 함수형 컴포넌트로 작성한다.
데이터 상태 변경에 따른 간단한 카운터 예제를 작성해본다.

```javascript
import { html, state } from '../core';

export default function Counter() {
  const data = state({
    count: 0,
  });

  const increase = () => {
    data.count += 1;
  }

  const decrease = () => {
    data.count -= 1;
  }

  return html`
    <div id="app">
      <button type="button" @click=${increase}>increase</button>
      <button type="button" @click=${decrease}>decrease</button>
      <div>${data.count}</div>
    </div>
  `;
}
```
함수형 컴포넌트의 경우 렌더링 시 매번 함수를 호출하기에 해당 컴포넌트의 상태, props, vdom, 라이프 사이클 등 

이를 관리해야 할 별도의 인스턴스가 필수적이다. 어찌보면 react class component와 비슷하다 볼 수 있다. 
본 프로젝트에서는 이를 ComponentInstance 객체로 구현한다. 아래 이미지는 해당 프로젝트의 전체 구성도이다.

![architecture](/images/ui1/architecture.png)

### 전체 순서
```bash
1. 함수형 컴포넌트를 가지고와 인스턴스를 생성한다.

2. 함수형 컴포넌트의 반환값을 가지고 Vdom을 생성한다.

3. Vdom을 가지고 실제 dom을 생성한다.

4. 실제 dom을 브라우저에 부착한다.

5. 상태 업데이트 시 이전 Vdom과 현재 VDom을 가지고 비교하여 실제 dom을 업데이트 한다.
```

컴포넌트가 실제 dom에 반영되려면 루트 엘리먼트로부터 컴포넌트가 부착되어야 한다.
루트 엘리먼트와 해당 컴포넌트를 **rootRender** 함수에 넘긴다.

```javascript
rootRender(document.getElementById('root'), Counter);
```
**runtime-dom.js**
```javascript
// 부착할 엘리먼트와 함수형 컴포넌트를 파라미터로 넘김
function rootRender(
  container,
  component,
) {
  const instance = new ComponentInstance(component, 0); // 컴포넌트를 관리할 인스턴스 생성
  instance.render(container);
  return instance;
}
```
**ComponentInstance**를 생성하기 위한 생성자 옵션으로 컴포넌트 함수와 html 트리에서의 고유 위치 넘버링을 넘긴다. 
루트 엘리먼트에 첫 부착되므로 0으로 넘긴다. 함수 컴포넌트 반환값의 경우 **html** 함수와 함께 렌더링할 선언적 dom 데이터를 넘겨주는데 html 함수는 문자열과 동적인 값을 넘겨주고 **marker**를 표시한채 그대로 넘긴다.

이는 웹 컴포넌트 기반 라이브러리 *lit*에서 컨셉을 차용했다. 

[https://github.com/lit/lit/blob/f243134b226735320b61466cebdaf0c1e574bfa7/packages/labs/ssr/src/lib/server-template.ts#L44](https://github.com/lit/lit/blob/f243134b226735320b61466cebdaf0c1e574bfa7/packages/labs/ssr/src/lib/server-template.ts#L44)

즉 html 함수의 역할은 추후 가상돔을 생성할 때 문자열에 표시된 **marker**에 동적값을 주입할 문자열 템플릿을 반환하는 것이다.

```javascript
function html(strings, ...values) {
  let idx = 0;
  const rawString = strings
    .join('%%identifier%%')
    .replace(/%%identifier%%/g, () => `__marker_${idx++}__`);

  return { template: rawString, values };
}
```
html 함수의 반환 값
```javascript
html`
  <div id="app">
    <button type="button" @click=${increase}>increase</button>
    <button type="button" @click=${decrease}>decrease</button>
    <div>${data.count}</div>
  </div>
`;

// 결과

{
  template: 
    <div id="app">
      <button type="button" data-testid="increase" @click=__marker_0__>increase</button>
      <button type="button" data-testid="decrease" @click=__marker_1__>decrease</button>
      <div id="value">__marker_2__</div>
    </div>,

  values: [f, f, 0],
}
```

## 컴포넌트 인스턴스

함수형 컴포넌트를 관리할 컴포넌트 인스턴스를 만든다. 인스턴스가 하는일은 다음과 같다.

```bash
1. 함수형 컴포넌트 원본과 상태를 보관
2. 렌더링 시 현재 인스턴스를 전역에 할당 (훅이 접근할 수 있도록)
3. VNode 생성 → 실제 DOM 생성 → 부모에 삽입
4. 리렌더링 시 새 DOM으로 교체
```
**component-instance.js**
```javascript
export default class ComponentInstance {
  states = [];        // 상태를 관리할 훅 배열
  parentElement;      // DOM이 삽입될 부모 엘리먼트
  component;          // 함수형 컴포넌트 원본
  prevVnodeTree;      // 이전 렌더링의 VNode
  nextVnodeTree;      // 현재 렌더링의 VNode
  currentDom;         // 실제 마운트된 DOM
  sequence;           // 트리에서의 위치 (전위순회 기준)
  hookIndex = 0;      // 훅 포인터 (마운트 전)
  hookLimit = 0;      // 훅 최대 개수 (마운트 후 고정)
  stateHookIndex = 0; // 상태 훅 포인터
  isMounted = false;  // 마운트 여부

  constructor(component, options) {
    this.component = component;
    this.sequence = options.sequence;
  }
}
```
**render 메서드 - 초기 마운트**

컴포넌트를 처음 DOM에 부착할 때 호출된다.

```javascript
render(parentElement, isRerender) {
  if (isRerender) {
    this.stateHookIndex = 0;
  }

  // 1. 현재 렌더링 중인 인스턴스를 전역에 할당
  currentInstance = this;

  // 2. 컴포넌트 함수 실행 → 템플릿 반환
  const template = this.component();

  this.parentElement = parentElement;

  // 3. 템플릿 → VNode 트리로 파싱
  this.prevVnodeTree = parse(template, this.sequence + 1);

  // 4. VNode → 실제 DOM 생성
  this.currentDom = createDOM(this.prevVnodeTree, parentElement);

  // 5. 부모에 DOM 삽입
  parentElement.insertBefore(this.currentDom, null);
  this.isMounted = true;
}
```


**reRender 메서드 - 상태 변경 시 재렌더링**

상태가 변경되면 호출되어 DOM을 교체한다.

```javascript
reRender() {
  this.stateHookIndex = 0;

  // 1. 현재 렌더링 중인 인스턴스를 전역에 할당
  currentInstance = this;

  // 2. 컴포넌트 함수 재실행
  const template = this.component();

  // 3. 새로운 VNode 트리 생성
  this.nextVnodeTree = parse(template, this.sequence + 1);

  // 4. 새 DOM 생성
  const newDom = createDOM(this.nextVnodeTree, this.parentElement);

  // 5. 기존 DOM을 새 DOM으로 일괄 교체
  this.currentDom.replaceWith(newDom);

  // 6. 참조 업데이트
  this.currentDom = newDom;
  this.prevVnodeTree = this.nextVnodeTree;
}
```

### 핵심: currentInstance 전역 할당

여기서 가장 중요한 로직은 **현재 렌더링 중인 인스턴스를 전역에 할당**하는 것이다.
이를 통해 훅 함수 내부 실행 시 현재 렌더링 진행중인 컴포넌트를 확인할 수 있다.
```javascript
currentInstance = this;
const template = this.component();
```

React 역시 렌더링 중인 Fiber 정보를 전역 변수에 등록하여 훅이 현재 실행 중인 컴포넌트를 추적한다.

[https://github.com/facebook/react/blob/2d8e7f1ce358e8cddc3aae862007269b6bac04ba/packages/react-reconciler/src/ReactFiberHooks.js#L261](https://github.com/facebook/react/blob/2d8e7f1ce358e8cddc3aae862007269b6bac04ba/packages/react-reconciler/src/ReactFiberHooks.js#L261)
![currentInstance](/images/ui1/current-instance.png)

## hook 로직 작성하기

state 훅이 하는 일은 다음과 같다.
```bash
1. 현재 렌더링 중인 인스턴스 가져오기 (어떤 컴포넌트에서 호출되었는지 파악)
2. 훅 유효성 검사 (조건부 호출 방지)
3. 리렌더링 시 이전 상태값 반환 (초기값이 아닌 저장된 값)
4. Proxy로 반응형 상태 생성 (값 변경 시 자동 리렌더링)
```

*Proxy vue의 반응성 컨셉을 사용하였으며 구현 단순화를 위해 Proxy 기반 반응성을 사용한다.*

### 1단계: 현재 인스턴스 가져오기

컴포넌트 함수 실행 전에 전역에 할당된 currentInstance를 가져온다.
이것이 React에서 훅이 **컴포넌트 내부에서만** 호출되어야 하는 이유다.

**hooks.js**
```javascript
import  { getCurrentInstance } from './component-instance';

function checkInvalidHook(currentInstance) {
  if (currentInstance.isMounted && currentInstance.hookIndex > currentInstance.hookLimit) {
    throw new Error('훅은 함수 최상단에 선언해야 합니다.');
  }

  if (!currentInstance.isMounted) {
    currentInstance.hookIndex += 1;
  }
}

export function state(initial) {
  const currentInstance = getCurrentInstance();

  // 컴포넌트 외부에서 호출하면 에러
  if (currentInstance === null) {
    throw new Error('state 함수는 컴포넌트 내에서 선언해야 합니다.');
  }
  // ...생략
}
```


### 2단계: 훅 유효성 검사

마운트 시점에 훅 개수를 기록해두고, 리렌더링 시 그 개수를 초과하면 에러를 던진다.

이것이 실제 react에서도 훅을 **조건부로 호출할 수 없는** 이유다.

```javascript
function checkInvalidHook(currentInstance) {
  // 마운트 후 훅 개수가 늘어나면 에러
  if (currentInstance.isMounted && currentInstance.hookIndex > currentInstance.hookLimit) {
    throw new Error('훅은 함수 최상단에 선언해야 합니다.');
  }

  // 마운트 전에는 훅 포인터 증가
  if (!currentInstance.isMounted) {
    currentInstance.hookIndex += 1;
  }
}
```

### 3단계: 이전 상태값 반환

매 렌더링마다 state()가 호출되지만, 초기값이 아닌 **이전에 저장된 상태**를 반환해야 한다.
stateHookIndex를 포인터로 사용해 states 배열에서 해당 순서의 상태를 가져온다.

```javascript
const stateIndex = currentInstance.stateHookIndex++;

// 이미 상태가 있으면 그대로 반환 (리렌더링 시)
if (currentInstance.states[stateIndex] !== undefined) {
  return currentInstance.states[stateIndex];
}
```

### 4단계: Proxy로 반응형 상태 생성

초기 마운트 시에만 실행된다. Proxy의 set trap을 활용해 값 변경 시 자동으로 리렌더링을 트리거한다.

```javascript
const data = new Proxy(initial, {
  get(target, key, receiver) {
    return Reflect.get(target, key, receiver);
  },

  set(target, key, value, receiver) {
    const prevValue = Reflect.get(receiver, key);
    const result = Reflect.set(target, key, value, receiver);

    // 값이 변경되면 리렌더링
    if (prevValue !== value) {
      currentInstance.reRender();
    }
    return result;
  },
});

// 인스턴스의 states 배열에 저장
currentInstance.states[stateIndex] = data;
return data;
```

### 훅 포인터가 동작하는 방식

아래와 같이 훅이 여러 개 있을 때 인스턴스 변수들이 어떻게 동작하는지 살펴보자.

```javascript
function Component() {
  const data1 = state({ foo: 1 }); // stateIndex = 0
  const data2 = state({ bar: 1 }); // stateIndex = 1
  return ...
}
```
**마운트 이전**

![before-mount](/images/ui1/before-mount.png)

마운트 이전에는 훅을 순회하면서 포인터를 증가시키고, states 배열에 초기값을 세팅한다.
마운트 완료 후 hookLimit에 훅 개수를 저장하여 이후 추가 훅 호출을 방지한다.
**마운트 이후 리렌더링**
![after-mount](/images/ui1/after-mount.png)

리렌더링 시에는 states 배열에 값이 이미 존재하므로 저장된 상태를 그대로 반환한다.

## 재조정 및 이벤트, 데이터 바인딩을 위한 Vdom 생성

앞서 html 함수에서 받은 결과물을 이제 실제로 dom에 부착해야 하는 작업이 남았다. Vdom을 생성하는 parser를 작성한다.

### 파서의 전체 흐름

파서가 하는 일을 단계별로 요약하면 다음과 같다.

```bash
1. template 문자열 → DOM으로 파싱 (브라우저 template 엘리먼트 활용)
2. DOM 노드 순회하면서 VNode로 변환 (convertNode, convertChild)
3. \_\_marker_N\_\_ 을 만나면 values 배열에서 실제 값으로 치환
4. 최종 VNode 트리 반환
```


**marker 치환 과정 예시**

```javascript
// 입력
html`<button @click=${onClick}>${count}개</button>`

// 1. html 함수 결과
{
  template: '<button @click=__marker_0__>__marker_1__개</button>',
  values: [onClick, 5]
}

// 2. parse 결과 (VNode)
{
  type: 'element',
  tag: 'button',
  attr: { '@click': onClick },  // marker_0 → onClick 함수
  children: [
    { type: 'text', value: '5개' }  // marker_1 → 5
  ]
}
```

### 1단계: 템플릿을 DOM으로 변환

html 함수에서 받은 template 문자열을 브라우저의 template 엘리먼트를 활용해 파싱한다.
template 엘리먼트는 innerHTML에 문자열을 넣으면 자동으로 DOM 트리를 생성해준다.

**parser.js**
```javascript
export default function parse(renderResult) {
  const { template: t } = renderResult;
  const template = document.createElement('template');

  template.innerHTML = t.trim();

  // 루트 엘리먼트는 1개여야 한다
  if (template.content.childNodes.length > 1) {
    throw new Error('루트 엘리먼트는 1개여야 합니다.');
  }

  const firstChild = template.content.firstChild;

  // 텍스트 노드라면
  if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
    return convertChild(firstChild);
  }

  return convertNode(template.content.firstElementChild);
}
```

### 2단계: 엘리먼트 노드 변환 (convertNode)

엘리먼트 노드를 VNode로 변환한다. 속성(attributes)을 순회하며 marker가 있으면 values 배열에서 실제 값을 가져온다.

```javascript
let valueIndex = 0;

function convertNode(el) {
  if (!el) {
    return { type: 'text', value: '' };
  }

  const attrs = {};
  for (const attr of el.attributes) {
    const { values } = renderResult;

    // marker 패턴 매칭
    const markers = attr.value.match(/__marker_(\d+)__/g);
    if (markers && markers.length >= 1) {
      // 함수면 이벤트 핸들러로 할당
      if (typeof values[valueIndex] === 'function') {
        attrs[attr.name] = values[valueIndex++];
      // 객체면 경고와 함께 할당
      } else if (typeof values[valueIndex] === 'object') {
        attrs[attr.name] = values[valueIndex++];
      // 원시값이면 문자열로 치환
      } else {
        attrs[attr.name] = attr.value.replace(/__marker_(\d+)__/g, () => {
          const v = values[valueIndex++];
          return v !== undefined ? String(v) : '';
        });
      }
    } else {
      // marker가 없으면 그대로 할당
      attrs[attr.name] = attr.value;
    }
  }

  // 자식 노드들을 재귀적으로 변환
  const children = [];
  for (const child of el.childNodes) {
    const vnode = convertChild(child);
    if (vnode) {
      children.push(vnode);
    }
  }

  return {
    type: 'element',
    tag: el.tagName.toLowerCase(),
    children,
    attr: attrs,
  };
}
```


### 3단계: 텍스트/자식 노드 변환 (convertChild)

텍스트 노드를 처리하고, marker가 있다면 실제 값으로 치환한다.
값이 또 다른 컴포넌트(renderResult 객체)라면 재귀적으로 parse를 호출한다.

```javascript
function convertChild(node) {
  // 텍스트 노드 처리
  if (node.nodeType === Node.TEXT_NODE) {
    let text = node.textContent ?? '';
    if (/^\s*$/.test(text)) return null; // 공백만 있으면 무시

    const markers = text.match(/__marker_(\d+)__/g);
    if (markers && markers.length >= 1) {
      return markers.map(() => {
        const { values } = renderResult;
        const value = values[valueIndex];

        // 값이 컴포넌트라면 재귀 파싱
        if (isRenderResultObject(value)) {
          return parse(value);
        }

        // 배열이면 각각 파싱
        if (Array.isArray(value)) {
          return values[valueIndex++].map((v) => {
            if (isRenderResultObject(v)) {
              return parse(v);
            }
          });
        }

        // 일반 값이면 텍스트로 치환
        text = replaceMarkers(text);
        return { type: 'text', value: text };
      });
    }

    return { type: 'text', value: text };
  }

  // 엘리먼트 노드면 convertNode로 위임
  if (node.nodeType === Node.ELEMENT_NODE) {
    return convertNode(node);
  }

  return null;
}
```


**파싱 결과 예시**
```javascript
const template = html`<div id="app" @click=${onClick}>${text}</div>`;
const result = parse(template);

// result
{
  type: 'element',
  tag: 'div',
  children: [ { type: 'text', value: 'text' } ],
  attr: { id: 'app', '@click': [Function: onClick] }
}
```

## VNode를 실제 DOM으로 변환

파싱된 VNode 트리를 실제 브라우저 DOM으로 변환한다.

### createDOM이 하는 일

1. **텍스트 노드면** → `document.createTextNode()` 로 생성
2. **엘리먼트 노드면** → `document.createElement()` 로 생성
3. **속성 처리** → `@click` 같은 이벤트는 `addEventListener`, 나머지는 `setAttribute`
4. **자식 노드 재귀 처리** → children을 순회하며 createDOM 재귀 호출

**runtime-dom.js**
```javascript
export function createDOM(vnode, parentElement) {
  // 1. 텍스트 노드 처리
  if (vnode.type === 'text') {
    return document.createTextNode(vnode.value);
  }

  // 2. 엘리먼트 생성
  const el = document.createElement(vnode.tag);

  // 3. 속성 처리
  if (vnode.attr) {
    for (const [key, value] of Object.entries(vnode.attr)) {
      // @click 같은 이벤트 바인딩
      if (/@([^\s=/>]+)/.test(key) && typeof value === 'function') {
        const eventName = key.slice(1);
        el.addEventListener(eventName, value);
      } else {
        el.setAttribute(key, value);
      }
    }
  }

  // 4. 자식 노드 재귀 처리
  vnode.children?.forEach((child) => {
    const c = createDOM(child, el);
    if (c) {
      el.appendChild(c);
    }
  });

  return el;
}
```

### DOM 삽입과 교체

생성한 DOM은 초기 렌더링 시 부모에 삽입하고, 리렌더링 시 기존 DOM을 교체한다.

```javascript
// 초기 렌더링: 부모에 삽입
this.currentDom = createDOM(this.prevVnodeTree, this.parentElement);
this.parentElement.insertBefore(this.currentDom, null);

// 리렌더링: 기존 DOM을 새 DOM으로 일괄 교체
const newDom = createDOM(this.nextVnodeTree, this.parentElement);
this.currentDom.replaceWith(newDom);
```

## 렌더링 최적화

현재 Proxy의 set trap은 속성이 변경될 때마다 리렌더링을 트리거한다.
여러 속성을 동시에 변경하면 그 횟수만큼 리렌더링이 발생한다.

```javascript
const data = state({ a: 0, b: 0 });

const trigger = () => {
  data.a += 1; // 리렌더링 1번
  data.b += 1; // 리렌더링 2번 → 비효율!
}
```

### requestAnimationFrame으로 배치 처리

대부분의 디스플레이 디바이스는 60Hz 주사율을 사용하므로 1프레임(약 16ms) 안에 발생한 모든 상태 변경을 모아서 **한 번만** 렌더링하면 된다.

**requestAnimationFrame**은 다음 프레임 직전에 콜백을 실행하므로, 같은 프레임 내의 여러 업데이트를 배치로 처리할 수 있다.


**배치 업데이트 흐름**
```
data.a += 1  →  큐에 인스턴스 추가, RAF 예약
data.b += 1  →  이미 큐에 있음, 무시
─────────────────────────────────────────
      ↓  (다음 프레임)

RAF 콜백 실행 → 큐의 인스턴스들 한 번씩 리렌더링
```
**update 함수 구현**

```javascript
const renderQueue = new Set(); // 중복 방지를 위해 Set 사용
let rafId = null;

export function update(instance) {
  // 1. 렌더링할 인스턴스를 큐에 추가
  renderQueue.add(instance);

  // 2. 이미 RAF가 예약되어 있으면 추가 예약 안 함
  if (rafId !== null) return;

  // 3. 다음 프레임에 배치 렌더링 예약
  rafId = requestAnimationFrame(() => {
    try {
      // 큐에 있는 모든 인스턴스 렌더링
      renderQueue.forEach((instance) => {
        instance.reRender();
      });
    } finally {
      // 정리
      renderQueue.clear();
      rafId = null;
    }
  });
}
```


**Proxy set trap에 적용**

기존의 reRender() 직접 호출을 update() 함수로 교체한다.

```javascript
set(target, key, value, receiver) {
  const prevValue = Reflect.get(receiver, key);
  const result = Reflect.set(target, key, value, receiver);

  if (prevValue !== value) {
    // reRender() 대신 update()로 배치 처리
    update(currentInstance);
  }
  return result;
}
```

이제 같은 프레임 내에서 아무리 많은 상태를 변경해도 **1번만 리렌더링**된다.

<iframe src="https://dkpark10.github.io/reona-track/01-state" width="100%" />

## 전체 파일

**index.js**
```javascript
import { state } from './hooks'

/**
 * @param {string[]} strings 
 * @param  {any[]} values 
 */
function html(strings, ...values) {
  let idx = 0;
  const rawString = strings
    .join('%%identifier%%')
    .replace(/%%identifier%%/g, () => `__marker_${idx++}__`);

  return { template: rawString, values };
}

export {
  state, html
};
```

**hooks.js**
```javascript
import  { getCurrentInstance } from './component-instance';

const renderQueue = new Set();
let rafId = null;

export function update(instance) {
  renderQueue.add(instance);

  if (rafId !== null) return;

  rafId = requestAnimationFrame(() => {
    try {
      renderQueue.forEach((instance) => {
        instance.reRender();
      });
    } finally {
      renderQueue.clear();
      rafId = null;
    }
  });
}

function isPrimitive(value) {
  return value === null || (typeof value !== 'object' && typeof value !== 'function');
}

function checkInvalidHook(currentInstance) {
  if (currentInstance.isMounted && currentInstance.hookIndex > currentInstance.hookLimit) {
    throw new Error('훅은 함수 최상단에 선언해야 합니다.');
  }

  if (!currentInstance.isMounted) {
    currentInstance.hookIndex += 1;
  }
}

export function state(initial) {
  const currentInstance = getCurrentInstance();
  if (currentInstance === null) {
    throw new Error('state 함수는 컴포넌트 내에서 선언해야 합니다.');
  }

  checkInvalidHook(currentInstance);

  const stateIndex = currentInstance.stateHookIndex++;
  if (currentInstance.states[stateIndex] !== undefined) {
    return currentInstance.states[stateIndex];
  }

  if (initial && isPrimitive(initial)) {
    throw new Error('원시객체 입니다. 객체 형식으로 넣으세요.');
  }

  const data = new Proxy(initial, {
    get(target, key, receiver) {
      return Reflect.get(target, key, receiver);
    },

    set(target, key, value, receiver) {
      const prevValue = Reflect.get(receiver, key);

      const result = Reflect.set(target, key, value, receiver);
      if (prevValue !== value) {
        update(currentInstance);
      }
      return result;
    },
  });
  currentInstance.states[stateIndex] = data;
  return data;
}
```

**component-instance.js**
```javascript
import parse from './parser';
import { createDOM } from './runtime-dom';

/** @description 현재 렌더링 되고 있는 컴포넌트 */
let currentInstance = null;
export function getCurrentInstance() {
  return currentInstance;
}

/** @description 컴포넌트 인스턴스 - 상태, Props, 생명주기, VNode 트리, DOM 참조를 관리 */
export default class ComponentInstance {
  /** @type {Array<unknown>} */
  states = [];

  /** @type {HTMLElement | null} */
  parentElement;

  /** @type {Function} */
  component;

  /** @type {Object | null} */
  prevVnodeTree;

  /** @type {Object | null} */
  nextVnodeTree;

  /** @type {HTMLElement | null} */
  currentDom;

  /** @type {Number} html 트리에서의 위치 */
  sequence;

  hookIndex = 0;

  hookLimit = 0;

  stateHookIndex = 0;

  isMounted = false;

  constructor(component, options) {
    this.component = component;
    this.sequence = options.sequence;
  }

  hookIndexInitialize() {
    this.stateHookIndex = 0;
  }

  render(parentElement, isRerender) {
    // 부모 리렌더링으로 인한 자식 리렌더링이라면
    if (isRerender) {
      this.hookIndexInitialize();
    }

    /** @description 현재 렌더링 되고 있는 컴포넌트를 할당 */
    currentInstance = this;
    const template = this.component();

    this.parentElement = parentElement;
    this.prevVnodeTree = parse(template, this.sequence + 1);

    this.currentDom = createDOM(this.prevVnodeTree, parentElement);
    parentElement.insertBefore(this.currentDom, null);
    this.isMounted = true;
    this.hookLimit = this.hookIndex;
  }

  reRender() {
    this.hookIndexInitialize();
    currentInstance = this;
    const template = this.component();

    this.nextVnodeTree = parse(template, this.sequence + 1);

    const newDom = createDOM(this.nextVnodeTree, this.parentElement);
    this.currentDom.replaceWith(newDom);

    // 새로운 값들을 이전 변수에 할당
    this.currentDom = newDom;
    this.prevVnodeTree = this.nextVnodeTree;
  }
}

```

**parser.js**
```javascript
import ComponentInstance from './component-instance';

/**
 * @typedef {Object} RenderResult
 * @property {string} template
 * @property {any[]} values
 */

/**
 * @param {RenderResult} obj
 * @returns {boolean}
 */
function isRenderResultObject(obj) {
  return (
    obj !== null &&
    typeof obj === 'object' &&
    typeof obj.template === 'string' &&
    Array.isArray(obj.values)
  );
}

/**
 * @param {Object} obj
 * @returns {boolean}
 */
export function isEmpty(obj) {
  return Object.keys(obj).length <= 0;
}

/**
 * @typedef {Object} VTextNode
 * @property {"text"} type
 * @property {string} value
 * @export
 */

/**
 * @typedef {Object} VElementNode
 * @property {"element"} type
 * @property {keyof HTMLElementTagNameMap} tag
 * @property {Props=} attr
 * @property {VNode[]} children
 * @export
 */

/**
 * @typedef {Object} VComponent
 * @property {"component"} type
 * @property {ComponentInstance} instance
 * @export
 */

/**
 * @typedef {VTextNode | VElementNode | VComponent} VNode
 * @export
 */

/**
 * @description 받은 html을 vnode tree로 만듬
 * @param {RenderResult} renderResult
 * @param {number} sequence
 * @returns {VNode}
 */
export default function parse(renderResult) {
  let valueIndex = 0;

  /**
   * @param {HTMLElement} el
   */
  function convertNode(el) {
    if (!el) {
      return {
        type: 'text',
        value: '',
      };
    }

    const attrs = {};

    for (const attr of el.attributes) {
      const { values } = renderResult;

      const nameMarker = attr.name.match(/^__marker_(\d+)__$/);
      if (nameMarker) {
        const value = values[valueIndex++];
        if (value && typeof value === 'string') {
          attrs[value] = true;
        }
        continue;
      }

      const markers = attr.value.match(/__marker_(\d+)__/g);
      if (markers && markers.length >= 1) {
        if (typeof values[valueIndex] === 'function') {
          attrs[attr.name] = values[valueIndex++];
        } else if (typeof values[valueIndex] === 'object') {
          attrs[attr.name] = values[valueIndex++];
          console.warn(
            `${el.tagName.toLowerCase()} 엘리먼트에 ${attr.name} 속성에 ${values[valueIndex - 1]} 객체가 들어가 있습니다. 값이 맞는지 확인하세요.`
          );
        } else {
          attrs[attr.name] = attr.value.replace(/__marker_(\d+)__/g, () => {
            const v = values[valueIndex++];
            return v !== undefined ? String(v) : '';
          });
        }
      } else {
        attrs[attr.name] = attr.value;
      }
    }

    const children = [];
    for (const child of el.childNodes) {
      const vnode = convertChild(child);
      if (vnode) {
        if (Array.isArray(vnode)) {
          const filteredEmptyTextValue = vnode.filter((node) => !!node).flat();
          children.push(...filteredEmptyTextValue);
        } else {
          children.push(vnode);
        }
      }
    }

    return {
      type: 'element',
      tag: el.tagName.toLowerCase(),
      children,
      ...(!isEmpty(attrs) && { attr: attrs }),
    };
  }

  /**
   * @param {ChildNode} node
   */
  function convertChild(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      let text = node.textContent ?? '';

      // 공백을 제거
      if (/^\s*$/.test(text)) return null;

      // marker가 붙어있는 경우가 있으므로 match
      const markers = text.match(/__marker_(\d+)__/g);
      if (markers && markers.length >= 1) {
        return markers.map(() => {
          const { values } = renderResult;
          const value = values[valueIndex];

          if (isRenderResultObject(value)) {
            const vdom = parse(value);
            return vdom;
          }

          // 배열이 들어 왔다면
          if (Array.isArray(value)) {
            const result = values[valueIndex++].map((value) => {
              if (isRenderResultObject(value)) {
                const vdom = parse(value);
                return vdom;
              }
            });
            return result;
          }

          // marker가 있다면 원본 텍스트를 변경한다.
          if (/__marker_(\d+)__/.test(text)) {
            text = replaceMarkers(text);
            return {
              type: 'text',
              value: text,
            };
          }
          // marker 가 없으면 빈 텍스트 반환
          return null;
        });
      }

      return {
        type: 'text',
        value: text,
      };
    }

    if (node.nodeType === Node.ELEMENT_NODE) {
      return convertNode(node);
    }

    return null;
  }

  /**
   * @param {string} str
   * @return {string}
   */
  function replaceMarkers(str) {
    const { values } = renderResult;
    return str.replace(/__marker_(\d+)__/g, () => {
      const v = values[valueIndex++];
      return v !== undefined ? String(v) : '';
    });
  }

  // 메인 파싱 로직
  const { template: t } = renderResult;
  const template = document.createElement('template');

  template.innerHTML = t.trim();

  if (template.content.childNodes.length > 1) {
    throw new Error('루트 엘리먼트는 1개여야 합니다.');
  }

  const firstChild = template.content.firstChild;

  /**
   * 텍스트 노드, 단일 컴포넌트 처리
   * html`text`, html`<component />`
   */
  if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
    const vDom = convertChild(firstChild);
    if (Array.isArray(vDom)) {
      return vDom.filter((v) => !!v)[0];
    }
    return vDom;
  }

  return convertNode(template.content.firstElementChild);
}
```

**runtime-dom.js**
```javascript
import ComponentInstance from "./component-instance";

export function rootRender(
  container,
  component,
) {
  if (!component) {
    throw new Error('컴포넌트가 없습니다.');
  }

  const instance = new ComponentInstance(component, 0);
  instance.render(container);
  return instance;
}

export function createDOM(vnode, parentElement) {
  if (vnode.type === 'text') {
    return document.createTextNode(vnode.value);
  }

  const el = document.createElement(vnode.tag);
  if (vnode.attr) {
    for (const [key, value] of Object.entries(vnode.attr)) {
      if (/@([^\s=/>]+)/.test(key) && typeof value === 'function') {
        const eventName = key.slice(1);
        el.addEventListener(eventName, value);
      } else {
        el.setAttribute(key, value);
      }
    }
  }

  vnode.children?.forEach((child) => {
    const c = createDOM(child, el);
    if (c) {
      el.appendChild(c);
    }
  });

  return el;
}
```
